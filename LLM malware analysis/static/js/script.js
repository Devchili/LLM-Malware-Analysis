document.getElementById('chatCompletionButton').addEventListener('click', async () => {
    const chatMessage = document.getElementById('chatMessageInput').value.trim();
    const fileInput = document.getElementById('fileInput').files[0];
    const responseOutput = document.getElementById('responseOutput');
    const loadingModal = document.getElementById('loadingModal');
    const downloadReportButton = document.getElementById('downloadReportButton');

    if (!chatMessage && !fileInput) {
        alert('Please enter a code snippet or upload a file.');
        return;
    }

    responseOutput.innerText = '';
    loadingModal.style.display = 'flex'; // Show the loading modal
    downloadReportButton.style.display = 'none';

    try {
        let fileContent = '';

        if (fileInput) {
            // Read the file content
            fileContent = await readFileContent(fileInput);
        }

        const formData = new FormData();

        // Use the file content as input if the file was uploaded, otherwise use the chat message
        if (fileContent) {
            formData.append('message', fileContent);
        } else if (chatMessage) {
            formData.append('message', chatMessage);
        }

        const response = await fetch('/api/malware-analysis', {
            method: 'POST',
            body: formData
        });

        if (!response.ok) {
            throw new Error(`Network response was not ok: ${response.statusText}`);
        }

        const result = await response.json();

        setTimeout(() => {
            loadingModal.style.display = 'none'; // Hide the loading modal

            let formattedResponse = result.analysis;
            responseOutput.innerText = formattedResponse;

            downloadReportButton.style.display = 'block';
            downloadReportButton.onclick = () => downloadReport(formattedResponse);

            showTab('results');

            // After saving to history, reload the history to show the new entry
            loadHistory(); 
        }, 5000); // 5 seconds delay
    } catch (error) {
        loadingModal.style.display = 'none'; // Hide the loading modal
        responseOutput.innerText = `Error: ${error.message}`;
        console.error('Error during chat completion:', error);
    }
});

// Function to read file content as text
function readFileContent(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.onload = (event) => {
            resolve(event.target.result);
        };

        reader.onerror = (event) => {
            reject(new Error('Error reading file'));
        };

        reader.readAsText(file); // Read the file content as text
    });
}

// Clear file input when the "X" button is clicked
document.getElementById('clearFileButton').addEventListener('click', () => {
    const fileInput = document.getElementById('fileInput');
    fileInput.value = ''; // Clear the file input
});

async function loadHistory() {
    const historyContent = document.getElementById('historyContent');
    historyContent.innerHTML = ''; // Clear existing content

    try {
        const response = await fetch('/api/get-history');
        const history = await response.json();

        console.log('Loaded history:', history);

        if (Object.keys(history).length === 0) {
            historyContent.innerHTML = '<p>No history available.</p>'; // Display a message if history is empty
            return;
        }

        Object.keys(history).forEach(type => {
            const typeSection = document.createElement('div');
            typeSection.className = 'my-4';

            const typeHeading = document.createElement('h3');
            typeHeading.className = 'text-xl font-bold text-red-500';
            typeHeading.innerText = type;
            typeSection.appendChild(typeHeading);

            history[type].forEach(item => {
                const historyItem = document.createElement('div');
                historyItem.className = 'p-4 my-2 bg-gray-700 text-gray-200 rounded-lg cursor-pointer flex justify-between items-center';
                
                const historyText = document.createElement('div');
                historyText.innerHTML = `<h4 class="font-bold">${item.name}</h4>`;
                historyText.addEventListener('click', () => {
                    showModal(item.name, item.content);
                });

                const deleteButton = document.createElement('button');
                deleteButton.className = 'text-red-500 hover:text-red-700';
                deleteButton.innerText = 'Delete';
                deleteButton.addEventListener('click', async (e) => {
                    e.stopPropagation(); // Prevent triggering the modal
                    await deleteHistory(type, item.name);
                    loadHistory(); // Reload history after deletion
                });

                historyItem.appendChild(historyText);
                historyItem.appendChild(deleteButton);

                typeSection.appendChild(historyItem);
            });

            historyContent.appendChild(typeSection);
        });
    } catch (error) {
        console.error('Error loading history:', error);
        historyContent.innerHTML = '<p>Error loading history.</p>';
    }
}

// Function to delete a history item
async function deleteHistory(category, name) {
    try {
        const response = await fetch('/api/delete-history', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ category, name })
        });

        if (!response.ok) {
            throw new Error('Failed to delete history item');
        }
    } catch (error) {
        console.error('Error deleting history:', error);
    }
}

// Function to show the modal with history content
function showModal(title, content) {
    document.getElementById('modalTitle').innerText = title;
    document.getElementById('modalContent').innerText = content;
    document.getElementById('historyModal').classList.remove('hidden');
    document.getElementById('historyModal').style.display = 'flex'; // Display the modal
}

// Function to close the modal
document.getElementById('closeModalButton').addEventListener('click', () => {
    document.getElementById('historyModal').classList.add('hidden');
    document.getElementById('historyModal').style.display = 'none'; // Hide the modal
});

async function downloadReport(reportContent) {
    try {
        const response = await fetch('/api/download-report', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ report: reportContent })
        });

        if (!response.ok) {
            throw new Error('Network response was not ok');
        }

        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'Malware_Analysis_Report.docx';
        document.body.appendChild(a);
        a.click();
        a.remove();
    } catch (error) {
        alert(`Failed to download report: ${error.message}`);
    }
}


console.log("File content:", fileContent);
console.log("Chat message:", chatMessage);

loadHistory(); // Load history on page load
