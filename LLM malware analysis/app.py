from flask import Flask, request, jsonify, render_template, send_file
from groq import Groq
from docx import Document
from io import BytesIO
import re
import json
import os

app = Flask(__name__)

# Initialize Groq client with the provided API key
client = Groq(api_key="your api key")

# Path to the JSON file where history will be stored
history_file = 'history.json'

# Function to load history from the JSON file
def load_history():
    if os.path.exists(history_file):
        with open(history_file, 'r') as f:
            return json.load(f)
    return {}

# Function to save history to the JSON file
def save_history(history):
    with open(history_file, 'w') as f:
        json.dump(history, f, indent=4)

# Function to format the text content for display
def format_text(content):
    # Remove ** markers from the content
    content = content.replace('**', '')

    # Add additional formatting for readability
    content = re.sub(r'(Name|Type|Behavior|Technical Details|Potential Impact|Mitigation Recommendations|Conclusion):', r'\n\1:\n', content)

    return content.strip()

@app.route('/')
def landing():
    return render_template('landing.html')

@app.route('/index')
def home():
    return render_template('index.html')

@app.route('/api/chat-completion', methods=['POST'])
def chat_completion():
    data = request.json
    user_message = data.get('message')

    if not user_message:
        return jsonify({'error': 'No message provided'}), 400

    chat_completion = client.chat.completions.create(
        messages=[
            {
                "role": "user",
                "content": user_message,
            }
        ],
        model="llama3-8b-8192",
    )

    response_message = chat_completion.choices[0].message.content
    return jsonify({'response': response_message})

@app.route('/api/malware-analysis', methods=['POST'])
def malware_analysis():
    file = request.files.get('file')
    message = request.form.get('message')

    # If a file is provided, use its content for analysis
    if file:
        try:
            file_content = file.read().decode('utf-8')
            input_content = file_content
            print(f"Using file content for analysis: {file_content[:100]}...")  # Print first 100 characters of file content
        except Exception as e:
            return jsonify({'error': f'Error reading file: {str(e)}'}), 400
    else:
        # If no file, use the message input
        input_content = message

    if not input_content:
        return jsonify({'error': 'No valid input content provided'}), 400

    analysis_result = client.chat.completions.create(
        messages=[
            {
                "role": "user",
                "content": f"Analyze the following code snippet to determine if it is malware. If it is not malware, simply respond with \"The Provided Code Is Not a Malware\". If it is malware, generate a malware analysis report with the following details: \n1. Name: The name of the malware\n2. Type: The type of malware (e.g., virus, worm, trojan, etc.)\n3. Behavior: The behavior and actions of the malware\n4. Technical Details: Detailed technical information about the malware\n5. Potential Impact: The potential impact of the malware\n6. Mitigation Recommendations: Recommendations for mitigating the malware\n7. Conclusion: A concluding summary of the analysis\n\nCode Snippet:\n{input_content}",
            }
        ],
        model="llama3-8b-8192",
    )

    response_message = analysis_result.choices[0].message.content

    # Format the response message
    formatted_response = format_text(response_message)

    # Extract the malware type using regex
    type_match = re.search(r'Type:\s*(.*)', formatted_response)
    malware_type = type_match.group(1).strip() if type_match else "Uncategorized"

    # Extract the name of the malware using regex
    name_match = re.search(r'Name:\s*(.*)', formatted_response)
    malware_name = name_match.group(1).strip() if name_match else "Unnamed Analysis"

    # Load current history
    history = load_history()

    # Ensure history[type] is an array
    if malware_type not in history:
        history[malware_type] = []

    # Append new result to the history
    history[malware_type].append({'name': malware_name, 'content': formatted_response})

    # Save updated history
    save_history(history)

    # Return the categorized result
    return jsonify({
        'analysis': formatted_response,
        'category': malware_type,
        'name': malware_name
    })

@app.route('/api/get-history', methods=['GET'])
def get_history():
    history = load_history()
    return jsonify(history)

@app.route('/api/delete-history', methods=['POST'])
def delete_history():
    data = request.json
    category = data.get('category')
    name = data.get('name')

    if not category or not name:
        return jsonify({'error': 'Invalid request'}), 400

    # Load current history
    history = load_history()

    if category in history:
        history[category] = [item for item in history[category] if item['name'] != name]
        if not history[category]:  # Remove the category if it is empty
            del history[category]

    # Save the updated history
    save_history(history)

    return jsonify({'success': True})

@app.route('/api/download-report', methods=['POST'])
def download_report():
    data = request.json
    report_content = data.get('report')

    if not report_content:
        return jsonify({'error': 'No report content provided'}), 400

    # Create a Word document
    document = Document()
    document.add_heading('Malware Analysis Report', 0)

    # Add the report content to the document
    paragraphs = report_content.split('\n')
    for para in paragraphs:
        document.add_paragraph(para)

    # Save the document to a BytesIO object
    doc_io = BytesIO()
    document.save(doc_io)
    doc_io.seek(0)

    return send_file(doc_io, as_attachment=True, download_name='Malware_Analysis_Report.docx')

if __name__ == '__main__':
    app.run(debug=True)
